\documentclass[12pt]{article} 

\title{Modelagem em multithread da interação entre colônias de formiga} 
\author{Germano Andrade, João Alcindo e Tiago da Silva} 
\date{\today} 

% language 
\usepackage[portuguese]{babel} 
% general packages 
\usepackage{amssymb} 
\usepackage{amsmath} 
\usepackage{amsthm} 
\usepackage{amsfonts} 
\usepackage{enumitem} 
\usepackage{tabularx} 

% figures 
\usepackage{graphicx} 
\usepackage{tikz} 
\usepackage{tkz-graph} 
\usetikzlibrary{arrows} 
% \usetikzlibrary{calc} 

% theorems environment 
\let \eps \epsilon 
\usepackage{fullpage} 

\newtheorem{theorem}{Teorema} 
\newtheorem{proposition}{Proposição} 

\theoremstyle{definition} 
% \newtheorem{problem}{Exercício} 
\newtheorem{definition}{Definição} 
\newtheorem{lemma}{Lema} 
\newtheorem*{description*}{Problema} 

\SetVertexNormal[Shape      = circle, 
                 LineWidth  = 2pt]
\SetUpEdge[lw         = 1.5pt]

\newcommand\exercisea{\@alpha{a, b, d}}  

\newtheorem{innercustomgeneric}{\customgenericname}
\providecommand{\customgenericname}{}
\newcommand{\newcustomtheorem}[2]{%
  \newenvironment{#1}[1]
  {%
   \renewcommand\customgenericname{#2}%
   \renewcommand\theinnercustomgeneric{##1}%
   \innercustomgeneric
  }
  {\endinnercustomgeneric}
}
\newcustomtheorem{problem}{Exercício}
 
\begin{document}  
	 
\maketitle  
\tableofcontents 

\section{Introdução} 

Neste documento, vamos descrever os aspectos que enformaram nossas implementações e caracterizaram as nossas decisões de modelagem; contemplaremos, além disso, situações tremendamente atribuladas que caracterizaram tanto a implementação serial -- em uma thread -- quanto a multithread deste sistema. Na seção seguinte, portanto, introduzimos os atributos gerais de nosso programa, enfatizando como os agentes -- as formigas, os formigueiros, as comidas e os objetos subjacentes, como os mapas e as coordenadas -- foram desenhados, e apontando, também, para a contemplação dos mecanismos que ensejam sua interação. 

Na seção subsequente, vislumbramos os alicereces que culminaram na versão mulithread do programa, explicitando a utilização de variáveis de exclusão mútua, de variáveis de condição e de semáforos com o objetivo de lograr as idiossincrasias inconvenientes das programação paralela, como as condições de corrida e a inanição (\textit{starvation}). 

\section{Desenho dos agentes} 

A simulação da interaçao entre formigueiros contempla, neste cenário, múltiplos agentes; em um momento inicial, portanto, é importante que os caracterizemos, garantindo que eles possam interagir consistentemente durante a simulação. Em nossa implementação, em particular, identificamos cada agente com uma classe; alguns gozam de múltiplas instâncias (como o agente \texttt{Ant}, formiga), e outros, não (como o agente \texttt{Map}, mapa). Explicitamente, introduzimos as classes 

\begin{enumerate} 
	\item \texttt{Anthill}, formigueiro, 
	\item \texttt{Ant}, formiga, 
	\item \texttt{Food}, comida, 
	\item \texttt{Map}, mapa e 
	\item \texttt{Tile}, azulejo (ou, equivalentemente, coordenada); 
\end{enumerate} 

\noindent elas estão, assim, descritas na Figura~\ref{fig:siml}. Perceba, logo, que as formigas estão amarradas ao formigueiro e, além disso, interagem com ele, incrementando o seu armazém de alimento; em contraste, a interação entre as formigas e a comida consiste no decremento de um atributo -- o volume da instância de comida; por outro lado, as formigas não modificam, objetivamente, os atributos das coordenadas do mapa -- eles que, na verdade, rastreiam, em uma tabela hash (em que as chaves correspondem aos nomes dos formigueiros) de pilhas, as formigas depositadas neles em cada iteração. Esta é, aliás, a interação mais crucial da simulação: as formigas se movem pelo mapa, identificam a comida, a capturam e, em um deslocamento para o formigueiro, incrementam o seu armazenamento de alimento. Nestas condições, o movimento das formigas é delicado; ele é, desta maneira, o tópico da seção seguinte. 

\begin{figure} 
	\centering 
	\includegraphics[width = \textwidth]{image.png} 
	\caption{Modelagem e interação dos agentes na simulação.} 
	\label{fig:siml} 
\end{figure} 

\subsection{Movimento das formigas} 

Em cada iteração, há incisivamente um tripleto de ações que as formigas podem executar: ou elas se movem aleatoriamente (método \texttt{moveRandomly}), ou elas se direcionam ao formigueiro (método \texttt{moveToColony}), ou elas procuram o alimento (método \texttt{moveToFood}; elas podem, também, entrar em combate; descreveremos, mais tarde, nossa aproximação para isso). Vislumbramos, nos itens seguintes, cada um desses movimentos. 

\begin{enumerate} 
	\item \texttt{moveRandomly}. No movimento aleatório, identificamos as coordenadas em que a formiga está e, em seguida, capturamos seus vizinhos\footnote{Que não contêm alimento; as formigas não interagem com estes azulejos -- elas modificam as instâncias da classe \texttt{Food} depositadas neles.}, verificando, importantemente, a sua existência (com esse objetivo, o método \texttt{getTile}, da classe \texttt{Map}, levanta uma exceção \texttt{BorderError}, sinalizando que o programa está acessando uma coordenada que transcende as bordas do mapa; o tratamento desta exceção, assim, garante a consistência da identificação das coordenadas vizinhas). Escolhemos, então, uma coordenada aleatoriamente; a probabilidade de uma instância ser escolhida é diretamente proporcional à quantidade de feromônio que ela contém\footnote{Encetamos, para isso, gerando uma variável aleatória uniformemente distribuída no intervalo unitário da reta real; instanciamos, também, uma \texttt{array} com as somas acumuladas das quantidades de feromônios (mais um; por exemplo, um objeto com um feromônio teria peso igual a dois, e um com dois, igual a três) em cada coordenada, \texttt{cumSum}. Aplicamos, então, uma divisão de cada elemento de \texttt{cumSum} pela quantidade total de fermônios nas vizinhanças, e verificamos, assim, o intervalo correspondente à variável aleatória uniforme, que equivale à nossa escolha aleatória.} (a liberação de feromônios é contemplada na seção seguinte). 
	\item \texttt{moveToColony}. Equipadas com alimento, as formigas se direcionam ao formigueiro -- elas têm a informação de sua localização. Elas executam, para isso, um movimento retilíneo, implementado como uma adaptação do algoritmo de Breseham: inicialmente, traçamos, no plano cartersiano, o segmento que amarra a coordenada atual da formiga à de seu formigueiro; na etapa subsequente, computamos a coordenada vizinha da formiga mais próxima deste segmento, e a movemos nesta direção.  
	\item \texttt{moveToFood}. As formigas envisionam, em seu movimento, coordenadas a uma distância caracterizada pelo atributo -- do mapa; todas as formigas, em todos os formigueiros, gozam de campos de visão idênticos (contudo, poderíamos modificar a função que identifica instâncias de \texttt{Food} nas vizinhanças e distinguir a busca por comida para cada formiga -- escolhemos, neste sentido, o desenho mais parcimonioso) --; portanto, elas podem verificar se há alimentos e executar um movimento informado. Neste caso, com as restrições de acesso simultâneo aos alimentos, este ``movimento informado" pode, com efeito, consistir em aguardar e, possivelmente, lutar.  
\end{enumerate} 


\end{document} 
